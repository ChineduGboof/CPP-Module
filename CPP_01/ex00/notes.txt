The Zombie class is defined in Zombie.hpp. It has a private string attribute _name, 
and a constructor that takes a string argument to set the zombie's name. 
It also has a destructor that prints a message when the zombie is destroyed, 
for debugging purposes. Finally, it has a public member function announce() 
that prints the zombie's name and a message.

The newZombie() function is defined in the same file as the main function. 
It takes a string argument, creates a new zombie on the heap using new, 
and returns a pointer to the zombie.

The randomChump() function is also defined in the same file as the main function. 
It takes a string argument, creates a new zombie on the stack with the given name, 
and calls the announce() function to print the zombie's message.

The main function creates three zombies: zombie1, zombie2, and zombie3. 
zombie1 is created on the stack by calling the Zombie constructor with 
the string argument "Zombie 1", and its announce() function is called 
to print its message. zombie2 is created on the heap using newZombie(), 
and its announce() function is called to print its message. zombie2 is 
then explicitly deleted using delete to avoid a memory leak. Finally, 
randomChump() is called with the argument "Zombie 3" to 
create and announce a third zombie on the stack.

Overall, this code demonstrates the use of classes, constructors, 
and destructors, as well as dynamic memory allocation and deallocation. 
It also shows the difference between creating objects on the stack and 
on the heap, and highlights the importance of properly managing heap-allocated 
objects to avoid memory leaks.

Now, as for your question about whether to allocate zombies on the stack or heap, 
here are some considerations:

If you only need a small number of zombies and know their lifetimes exactly, 
it's probably fine to allocate them on the stack. 
This way, they'll be automatically destroyed when they go out of scope.
If you need a large number of zombies, or don't know how many zombies 
you'll need ahead of time, it's probably better to allocate them on the heap using new. 
This way, you can control their lifetimes and delete them explicitly when you're done with them.
That being said, it's always a good idea to use smart pointers 
(e.g. std::unique_ptr or std::shared_ptr) to manage heap-allocated objects, 
as they help ensure that the objects are properly destroyed and avoid memory leaks.